// @ts-ignore
import * as snarkjs from 'snarkjs';
import * as fs from 'fs';
import * as path from 'path';

export class ZkVerifier {
    private vKey: any;
    private initialized: boolean = false;

    constructor() {
        this.loadKey();
    }

    private loadKey() {
        try {
            // Adjust path based on execution context (root or dist)
            // Assuming standard run from root
            const vKeyPath = path.join(process.cwd(), 'circuits', 'verification_key.json');
            if (fs.existsSync(vKeyPath)) {
                this.vKey = JSON.parse(fs.readFileSync(vKeyPath, 'utf-8'));
                this.initialized = true;
                console.log('[ZkVerifier] Verification key loaded successfully.');
            } else {
                console.warn(`[ZkVerifier] Verification key not found at ${vKeyPath}. ZK Verification will fail.`);
            }
        } catch (error) {
            console.error('[ZkVerifier] Failed to load verification key:', error);
        }
    }

    /**
     * Verifies a ZK proof for metadata integrity.
     * @param proof The proof object generated by snarkjs
     * @param publicSignals The public signals (pubHash)
     * @returns boolean indicating validity
     */
    async verifyMetadataProof(proof: any, publicSignals: string[]): Promise<boolean> {
        if (!this.initialized) {
            // Try loading again in case it was generated late
            this.loadKey();
            if (!this.initialized) {
                console.error('[ZkVerifier] Key not initialized.');
                return false;
            }
        }

        try {
            const verified = await snarkjs.groth16.verify(this.vKey, publicSignals, proof);
            console.log(`[ZkVerifier] Proof verification result: ${verified}`);
            return verified;
        } catch (error) {
            console.error('[ZkVerifier] Verification error:', error);
            return false;
        }
    }
}
